---
layout: default
classes: wide
title: "천원돌파 의존성 역전(가제)(2)"
date: 2024-02-06
categories: Before_proofreading
---

## 다른 형태로 의존성 역전을 구현하는 방법

여태까지는 의존성 역전을 구현하는 방법으로 상위 모듈이 하위 모듈을 추상화한 인터페이스나 추상 클래스에 의존하도록 하는 방법을 살펴봤습니다. 그러나 제가 이야기하는 것은 추상화한 인터페이스나 클래스 도입에 따른 결합도 감소 및 유연성 높이는 방법이 아닌, 의존성 역전 패턴입니다. 그 이유는 이제 다음에 이야기할 추가적인 두가지 형태로 의존성 역전을 구현하는 것이 가능하기 때문입니다.

* 의존성 주입
* 제어 역전

의존성 주입은 객체가 직접 자신이 사용할 객체를 생성하는 것이 아니라, 외부에서 객체를 주입받아 사용하는 방식을 말합니다. 이는 객체의 생성과 사용을 분리함으로써 객체의 재사용성을 높이고, 유연성을 높이는 장점이 있습니다. 의존성 주입은 다음과 같은 코드를 개선해야 하는 상황에서 사용할 수 있습니다.

```python
class DataAnalyzer:
    def __init__(self):
        self.file_manager = BinaryFileManager()

    def process_data(self, file_name):
        self.file_manager.open_file(file_name)
        self.analyze_data()

    def analyze_data(self):
        data = self.file_manager.read_file()
        if data:
            ones_count = self.count_ones(data)
            print(f"Number of ones in the file: {ones_count}")
        else:
            print("No file open.")

    def count_ones(self, data):
        return data.count('1')
```

위의 코드에서 DataAnalyzer는 BinaryFileManager를 직접 생성하고 사용하고 있습니다. 이는 DataAnalyzer가 BinaryFileManager에 의존하고 있음을 의미합니다. 이를 의존성 주입을 통해 개선하면 다음과 같이 작성할 수 있습니다.

```python
class DataAnalyzer:
    def __init__(self, file_manager):
        self.file_manager = file_manager

    def process_data(self, file_name):
        self.file_manager.open_file(file_name)
        self.analyze_data()

    def analyze_data(self):
        data = self.file_manager.read_file()
        if data:
            ones_count = self.count_ones(data)
            print(f"Number of ones in the file: {ones_count}")
        else:
            print("No file open.")

    def count_ones(self, data):
        return data.count('1')
```

의존성 주입을 통해 DataAnalyzer는 BinaryFileManager를 직접 생성하지 않고, 외부에서 주입받아 사용하고 있습니다. 이는 DataAnalyzer가 BinaryFileManager에 의존하지 않고, 외부에서 주입받은 객체에 의존하고 있음을 의미합니다.

그러나 의존성 주입은 객체의 생성과 사용을 분리함으로써 객체의 재사용성을 높이고, 유연성을 높이는 장점이 있지만, 객체를 생성하고 주입하는 코드가 복잡해질 수 있습니다. 

2. 제어 역전

이를 해결하기 위해 등장한 개념이 바로, 제어 역전입니다. 제어 역전은 객체의 생성과 사용을 분리함으로써 객체의 재사용성을 높이고, 유연성을 높이는 장점을 가지면서도, 객체를 생성하고 주입하는 코드가 복잡해지는 문제를 해결하기 위해 등장한 개념입니다.

제어 역전은 객체의 생성과 사용을 분리하기 위해 객체를 생성하고 사용하는 책임을 외부에 위임하는 것을 말합니다. 아까 전까지 이야기 한 의존성 주입과 얼핏 보면 동일한 이야기를 하는 것으로 이야기하기 쉽습니다. 하지만 의존성 주입은 객체를 생성하고 사용하는 책임을 외부에 위임하는 반면, 제어 역전은 객체를 생성하고 사용하는 책임을 객체 자신이 가지고 있는 것을 말합니다.

이 둘이 어떻게 다른지에 이해하기 위해서는 예시 코드를 통해 확인하는 것이 더 빠를 것입니다. 다음과 같은 코드를 살펴보겠습니다.

이제 우리가 위에서 작성한 DataAnalyzer를 사용하는 코드를 살펴보겠습니다.

```python
data_analyzer = DataAnalyzer(BinaryFileManager())
data_analyzer.process_data(sample_file_name)
```

만약 우리가 data_analyzer를 통해 BinaryFileManager를 사용하려 한다면, 위와 같은 코드를 사용하게 됩니다. 하지만 만약 기획이 바뀌어 우리에게 TextFileManager를 사용하라는 요구사항이 생긴다면, 우리는 다음과 같이 코드를 변경해야 할 것입니다.

```python
data_analyzer = DataAnalyzer(TextFileManager())
```

이처럼 의존성 주입을 사용하고 있더라도, 기존의 방식으로는 여전히 객체를 생성하고 사용하는 책임을 외부에 위임하고 있습니다. 이를 해결하기 위해 등장한 개념이 바로, 제어 역전입니다. 제어 역전은 객체의 생성과 사용을 분리하기 위해 객체를 생성하고 사용하는 책임까지도 외부에 위임하는 것을 말합니다.

위의 코드를 제어 역전을 사용하여 개선하면 다음과 같이 작성할 수 있습니다.

```python
class FileManagerController:
    def __init__(self, file_manager):
        self.file_manager = file_manager

    def get_file_manager(self):
        return self.file_manager

    def set_file_manager(self, file_type):
        if file_type == 'binary':
            self.file_manager = BinaryFileManager()
        elif file_type == 'text':
            self.file_manager = TextFileManager()

file_manager = BinaryFileManager()
file_manager_controller = FileManagerController(file_manager)
data_analyzer = DataAnalyzer(file_manager_controller.get_file_manager())
data_analyzer.process_data(sample_file_name)
```

분명 FileManagerController가 들어와서 제어가 역전됐는데, 얼핏 보기에는 코드가 복잡해지고 있는 것처럼 보일 수 있습니다. 그러면 더 나아가서, 만약 우리가 이 데이터 분석 모듈을 웹서버에 탑재해야하는 경우를 상정해보면 어떨까요?

```python
class WebServer:
    def __init__(self, data_analyzer):
        self.data_analyzer = data_analyzer

    def handle_request(self, file_name, file_type):
        self.file_manager_controller.set_file_manager(file_type)
        self.data_analyzer = DataAnalyzer(self.file_manager_controller.get_file_manager())
        self.data_analyzer.process_data(file_name)
```

이제 우리는 보내오는 파일이 어떤 형태이든지간에, FileManagerController만이 이것을 처리할 뿐 이를 이용하는 WebServer는 어떤 파일이 들어오든지간에, FileManagerController에게 파일의 형태를 알려주기만 하면 됩니다. 다음처럼 말입니다.

```python
file_manager_controller = FileManagerController()
web_server = WebServer(file_manager_controller)

web_server.handle_request("data.bin", 'binary')
web_server.handle_request("data.txt", 'text')
```